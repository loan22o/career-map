# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v8ragaHwEMMyWD11oPMHL5-VNbOxMpyS
"""

!pip install streamlit pandas plotly

# Commented out IPython magic to ensure Python compatibility.
# # mbti.py
# %%writefile mbti.py
# 
# def mbti_quiz():
#     """
#     This is a placeholder function for the MBTI quiz.
#     Replace this with your actual implementation.
#     It should return the determined MBTI type (e.g., "ISTJ").
#     """
#     # Example placeholder logic:
#     # In a real application, you would implement a quiz
#     # and determine the MBTI type based on user answers.
#     print("Running a placeholder MBTI quiz...")
#     return "INFJ" # Example return value
# 
# def suggest_career(mbti_type, skills, major):
#     """
#     This is a placeholder function to suggest careers based on MBTI, skills, and major.
#     Replace this with your actual implementation.
#     It should return a list of suggested careers.
#     """
#     # Example placeholder logic:
#     print(f"Suggesting careers for MBTI: {mbti_type}, Skills: {skills}, Major: {major}")
#     # In a real application, you would use these inputs
#     # to find relevant career suggestions.
#     suggestions = [
#         f"Placeholder Career 1 for {mbti_type}",
#         f"Placeholder Career 2 for {major}",
#         f"Placeholder Career 3 for {', '.join(skills)}"
#     ]
#     return suggestions

# Commented out IPython magic to ensure Python compatibility.
# # app.py
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import plotly.express as px
# from mbti import mbti_quiz, suggest_career
# 
# # Load d·ªØ li·ªáu ƒë√£ l√†m s·∫°ch
# @st.cache_data
# def load_data():
#     df = pd.read_csv("data/Cleaned data.csv")
#     df = df.dropna(subset=['Industry', 'Location.1', 'Min Salary', 'Max Salary'])
#     return df
# 
# df = load_data()
# 
# st.set_page_config(page_title="CareerMap", layout="wide")
# st.title("üéØ CareerMap ‚Äì N·ªÅn t·∫£ng h∆∞·ªõng nghi·ªáp c√° nh√¢n h√≥a")
# 
# # MBTI Test
# st.header("üß† Tr·∫Øc nghi·ªám MBTI ƒë∆°n gi·∫£n")
# # Note: In a real Streamlit app, you would likely use st.session_state
# # to store the MBTI type after the quiz is completed.
# # For now, this placeholder function is called directly.
# mbti_type = mbti_quiz()
# 
# # Nh·∫≠p k·ªπ nƒÉng v√† ng√†nh h·ªçc
# st.header("üõ†Ô∏è K·ªπ nƒÉng v√† ng√†nh h·ªçc")
# skills = st.multiselect("B·∫°n c√≥ nh·ªØng k·ªπ nƒÉng n√†o?", ["Ph√¢n t√≠ch d·ªØ li·ªáu", "L·∫≠p tr√¨nh", "Giao ti·∫øp", "Thi·∫øt k·∫ø", "Qu·∫£n l√Ω d·ª± √°n"])
# major = st.selectbox("Ng√†nh b·∫°n ƒëang h·ªçc l√† g√¨?", ["Kinh t·∫ø", "C√¥ng ngh·ªá th√¥ng tin", "Truy·ªÅn th√¥ng", "K·ªπ thu·∫≠t", "Du l·ªãch"])
# 
# # G·ª£i √Ω ngh·ªÅ nghi·ªáp
# # Ensure mbti_type is not None or empty before showing the button
# if mbti_type and st.button("üéØ Xem g·ª£i √Ω ngh·ªÅ nghi·ªáp"):
#     suggestions = suggest_career(mbti_type, skills, major)
#     st.subheader("üîç Ngh·ªÅ nghi·ªáp ph√π h·ª£p v·ªõi b·∫°n:")
#     for job in suggestions:
#         st.markdown(f"- {job}")
# 
# # Tr·ª±c quan h√≥a d·ªØ li·ªáu
# st.header("üìä Ph√¢n t√≠ch xu h∆∞·ªõng th·ªã tr∆∞·ªùng")
# 
# col1, col2 = st.columns(2)
# 
# with col1:
#     avg_salary_industry = df.groupby("Industry")["Min Salary"].mean().reset_index()
#     fig1 = px.bar(avg_salary_industry, x="Industry", y="Min Salary", title="üíº L∆∞∆°ng trung b√¨nh theo ng√†nh")
#     st.plotly_chart(fig1, use_container_width=True)
# 
# with col2:
#     avg_salary_location = df.groupby("Location.1")["Min Salary"].mean().reset_index()
#     fig2 = px.bar(avg_salary_location, x="Location.1", y="Min Salary", title="üåç L∆∞∆°ng theo ƒë·ªãa ƒëi·ªÉm")
#     st.plotly_chart(fig2, use_container_width=True)
# 
# # L∆∞∆°ng theo kinh nghi·ªám
# st.subheader("üìà L∆∞∆°ng trung b√¨nh theo kinh nghi·ªám")
# # Handle potential errors if 'EXP' column is not found or extraction fails
# try:
#     # Ensure the column exists and apply the extraction
#     if 'EXP' in df.columns:
#         df["EXP"] = df["EXP"].astype(str).str.extract(r'(\d)').dropna().astype(int)
#         # Filter out rows where EXP could not be converted to int after dropna
#         df_exp_filtered = df.dropna(subset=["EXP"])
#         if not df_exp_filtered.empty:
#             avg_exp = df_exp_filtered.groupby("EXP")["Min Salary"].mean().reset_index()
#             fig3 = px.line(avg_exp, x="EXP", y="Min Salary", markers=True, title="üìà L∆∞∆°ng theo s·ªë nƒÉm kinh nghi·ªám")
#             st.plotly_chart(fig3, use_container_width=True)
#         else:
#             st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu kinh nghi·ªám h·ª£p l·ªá ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.")
#     else:
#          st.warning("C·ªôt 'EXP' kh√¥ng t·ªìn t·∫°i trong d·ªØ li·ªáu.")
# 
# except Exception as e:
#     st.error(f"ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu kinh nghi·ªám: {e}")
# 
# 
# st.caption("Ngu·ªìn d·ªØ li·ªáu: TopCV, VietnamWorks ‚Äì x·ª≠ l√Ω b·ªüi nh√≥m CareerMap")

# Commented out IPython magic to ensure Python compatibility.
# # app.py
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import plotly.express as px
# from mbti import mbti_quiz, suggest_career
# # import os # No longer needed
# 
# # Load d·ªØ li·ªáu ƒë√£ l√†m s·∫°ch
# @st.cache_data
# def load_data():
#     # Construct the full path using the current working directory
#     # Make sure the 'data' folder is in the same directory as app.py
#     # file_path = os.path.join(os.path.dirname(__file__), "data", "Cleaned data.csv") # This caused the error
#     # Assuming 'data' is a subdirectory of the current working directory
#     file_path = "data/Cleaned data.csv"
# 
#     # Check if the file exists before trying to read it
#     # Using relative path, so check directly
#     try:
#         df = pd.read_csv(file_path)
#         df = df.dropna(subset=['Industry', 'Location.1', 'Min Salary', 'Max Salary'])
#         return df
#     except FileNotFoundError:
#         st.error(f"L·ªói: Kh√¥ng t√¨m th·∫•y t·ªáp d·ªØ li·ªáu t·∫°i ƒë∆∞·ªùng d·∫´n: {file_path}. ƒê·∫£m b·∫£o th∆∞ m·ª•c 'data' v√† t·ªáp 'Cleaned data.csv' t·ªìn t·∫°i ·ªü v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi.")
#         # Return empty DataFrame to prevent further errors
#         return pd.DataFrame()
# 
# 
# df = load_data()
# 
# st.set_page_config(page_title="CareerMap", layout="wide")
# st.title("üéØ CareerMap ‚Äì N·ªÅn t·∫£ng h∆∞·ªõng nghi·ªáp c√° nh√¢n h√≥a")
# 
# # MBTI Test
# st.header("üß† Tr·∫Øc nghi·ªám MBTI ƒë∆°n gi·∫£n")
# mbti_type = mbti_quiz()
# 
# # Nh·∫≠p k·ªπ nƒÉng v√† ng√†nh h·ªçc
# st.header("üõ†Ô∏è K·ªπ nƒÉng v√† ng√†nh h·ªçc")
# skills = st.multiselect("B·∫°n c√≥ nh·ªØng k·ªπ nƒÉng n√†o?", ["Ph√¢n t√≠ch d·ªØ li·ªáu", "L·∫≠p tr√¨nh", "Giao ti·∫øp", "Thi·∫øt k·∫ø", "Qu·∫£n l√Ω d·ª± √°n"])
# major = st.selectbox("Ng√†nh b·∫°n ƒëang h·ªçc l√† g√¨?", ["Kinh t·∫ø", "C√¥ng ngh·ªá th√¥ng tin", "Truy·ªÅn th√¥ng", "K·ªπ thu·∫≠t", "Du l·ªãch"])
# 
# # G·ª£i √Ω ngh·ªÅ nghi·ªáp
# # Add a check if df is empty from load_data error
# if mbti_type and st.button("üéØ Xem g·ª£i √Ω ngh·ªÅ nghi·ªáp"):
#     suggestions = suggest_career(mbti_type, skills, major)
#     st.subheader("üîç Ngh·ªÅ nghi·ªáp ph√π h·ª£p v·ªõi b·∫°n:")
#     for job in suggestions:
#         st.markdown(f"- {job}")
# 
# # Tr·ª±c quan h√≥a d·ªØ li·ªáu
# st.header("üìä Ph√¢n t√≠ch xu h∆∞·ªõng th·ªã tr∆∞·ªùng")
# 
# # Add a check to ensure df is not empty before plotting
# if not df.empty:
#     col1, col2 = st.columns(2)
# 
#     with col1:
#         avg_salary_industry = df.groupby("Industry")["Min Salary"].mean().reset_index()
#         fig1 = px.bar(avg_salary_industry, x="Industry", y="Min Salary", title="üíº L∆∞∆°ng trung b√¨nh theo ng√†nh")
#         st.plotly_chart(fig1, use_container_width=True)
# 
#     with col2:
#         avg_salary_location = df.groupby("Location.1")["Min Salary"].mean().reset_index()
#         fig2 = px.bar(avg_salary_location, x="Location.1", y="Min Salary", title="üåç L∆∞∆°ng theo ƒë·ªãa ƒëi·ªÉm")
#         st.plotly_chart(fig2, use_container_width=True)
# 
#     # L∆∞∆°ng theo kinh nghi·ªám
#     st.subheader("üìà L∆∞∆°ng trung b√¨nh theo kinh nghi·ªám")
#     # Handle potential errors if 'EXP' column is not found or extraction fails
#     try:
#         # Ensure the column exists and apply the extraction
#         if 'EXP' in df.columns:
#             # Ensure data in 'EXP' is string before applying str methods
#             # Add error handling for conversion if some values aren't convertible
#             df["EXP"] = df["EXP"].astype(str).str.extract(r'(\d)').dropna()
#             # Convert to int only after dropping NaNs
#             df["EXP"] = df["EXP"].astype(int)
# 
#             # Filter out rows where EXP could not be converted to int after dropna (though astype(int) would raise error first)
#             # A better approach might be to use .loc for assignment after filtering
#             df_exp_filtered = df.dropna(subset=["EXP"])
# 
#             if not df_exp_filtered.empty:
#                 avg_exp = df_exp_filtered.groupby("EXP")["Min Salary"].mean().reset_index()
#                 fig3 = px.line(avg_exp, x="EXP", y="Min Salary", markers=True, title="üìà L∆∞∆°ng theo s·ªë nƒÉm kinh nghi·ªám")
#                 st.plotly_chart(fig3, use_container_width=True)
#             else:
#                 st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu kinh nghi·ªám h·ª£p l·ªá ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.")
#         else:
#              st.warning("C·ªôt 'EXP' kh√¥ng t·ªìn t·∫°i trong d·ªØ li·ªáu.")
# 
#     except Exception as e:
#         st.error(f"ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu kinh nghi·ªám: {e}")
# else:
#     st.warning("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì.")
# 
# 
# st.caption("Ngu·ªìn d·ªØ li·ªáu: TopCV, VietnamWorks ‚Äì x·ª≠ l√Ω b·ªüi nh√≥m CareerMap")